/**
 * ===========================================
 * PROFILE API - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
 * ===========================================
 * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∑–∞–ø—Ä–æ—Å—ã –¥–ª—è:
 * - –ü–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * - –û–±–Ω–æ–≤–ª–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏
 * - –£–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è–º–∏
 * - –†–∞–±–æ—Ç—ã —Å —Å–∏—Å—Ç–µ–º–æ–π —É—Ä–æ–≤–Ω–µ–π
 */

import { createClient } from '@supabase/supabase-js'

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Supabase
const supabaseUrl = process.env.SUPABASE_URL
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY

if (!supabaseUrl || !supabaseServiceKey) {
  throw new Error('Missing Supabase credentials in environment variables')
}

const supabase = createClient(supabaseUrl, supabaseServiceKey)

/**
 * Validates Telegram WebApp init data
 */
function validateTelegramWebAppData(initData) {
  // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ - –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ –Ω—É–∂–Ω–∞ –ø–æ–ª–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è
  try {
    const urlParams = new URLSearchParams(initData)
    const user = urlParams.get('user')
    if (!user) return null

    return JSON.parse(user)
  } catch (error) {
    console.error('Invalid Telegram data:', error)
    return null
  }
}

/**
 * –ü–æ–ª—É—á–∞–µ—Ç –∏–ª–∏ —Å–æ–∑–¥–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –ë–î
 */
async function ensureUser(telegramId, userData = {}) {
  const { data: existingUser, error: fetchError } = await supabase
    .from('users')
    .select('*')
    .eq('telegram_id', telegramId)
    .single()

  if (fetchError && fetchError.code !== 'PGRST116') {
    throw new Error(`Database error: ${fetchError.message}`)
  }

  if (existingUser) {
    const updates = {}

    // –í–°–ï–ì–î–ê –æ–±–Ω–æ–≤–ª—è–µ–º last_visit_date –ø—Ä–∏ –ª—é–±–æ–º –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ API
    updates.last_visit_date = new Date().toISOString()
    updates.updated_at = new Date().toISOString()

    // –ï—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è - –¥–æ–±–∞–≤–ª—è–µ–º –∏—Ö –∫ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è–º
    if (userData && Object.keys(userData).length > 0) {
      // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ–ø—É—Å—Ç—ã–µ –ø–æ–ª—è
      if (userData.first_name) updates.first_name = userData.first_name
      if (userData.last_name) updates.last_name = userData.last_name
      if (userData.username) updates.username = userData.username
      if (userData.photo_url) updates.photo_url = userData.photo_url
      if (userData.language_code) updates.language_code = userData.language_code
    }

    console.log(
      `üìù Updating user ${telegramId} (including last_visit_date):`,
      updates
    )

    const { data: updatedUser, error: updateError } = await supabase
      .from('users')
      .update(updates)
      .eq('telegram_id', telegramId)
      .select()
      .single()

    if (updateError) {
      console.error('Failed to update user:', updateError)
      return existingUser // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
    }

    console.log(
      `‚úÖ User ${telegramId} updated successfully with last_visit_date`
    )
    return updatedUser
  }

  // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  console.log(`üÜï Creating new user ${telegramId} with data:`, userData)

  const { data: newUser, error: createError } = await supabase
    .from('users')
    .insert({
      telegram_id: telegramId,
      user_id: `tg_${telegramId}`, // –ò–°–ü–†–ê–í–õ–ï–ù–û: –¥–æ–±–∞–≤–ª–µ–Ω–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ user_id
      first_name: userData.first_name || null,
      last_name: userData.last_name || null,
      username: userData.username || null,
      photo_url: userData.photo_url || null,
      language_code: userData.language_code || 'ru',
      // registration_date –±—É–¥–µ—Ç —Ä–∞–≤–Ω–∞ created_at (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤ –ë–î)
      experience: 0,
      level: 1,
    })
    .select()
    .single()

  if (createError) {
    throw new Error(`Failed to create user: ${createError.message}`)
  }

  return newUser
}

/**
 * –í—ã—á–∏—Å–ª—è–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
async function calculateUserStats(user) {
  try {
    // –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
    const [
      { data: moodEntries, error: moodError },
      { data: gardenElements, error: gardenError },
    ] = await Promise.all([
      supabase
        .from('mood_entries')
        .select('mood_date, mood')
        .eq('telegram_id', user.telegram_id)
        .order('mood_date', { ascending: false }),

      supabase
        .from('garden_elements')
        .select('rarity, unlock_date')
        .eq('telegram_id', user.telegram_id),
    ])

    const userStats = user

    if (moodError || gardenError) {
      console.error('Stats calculation error:', {
        moodError,
        gardenError,
      })
      return null
    }

    // üî• V3: –°—Ç—Ä–∏–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –Ω–∞ –±—ç–∫–µ–Ω–¥–µ —á–µ—Ä–µ–∑ streak_last_checkin
    // –ú—ã –ù–ï –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –µ–≥–æ –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π, –∞ –±–µ—Ä–µ–º –¢–û–õ–¨–ö–û –∏–∑ –ë–î
    const currentStreak = userStats?.current_streak || 0
    const longestStreak = userStats?.longest_streak || 0

    console.log(
      `üìä STREAK [V3 Profile]: Using server-managed streak from DB: current=${currentStreak}, longest=${longestStreak}`
    )

    // –ü–æ–¥—Å—á–µ—Ç —Ä–µ–¥–∫–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    const rareElementsCount = gardenElements
      ? gardenElements.filter(el =>
          ['rare', 'epic', 'legendary'].includes(el.rarity)
        ).length
      : 0

    // –î–Ω–∏ —Å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
    const registrationDate = user.created_at || user.registration_date
    const daysSinceRegistration = registrationDate
      ? Math.floor(
          (Date.now() - new Date(registrationDate).getTime()) /
            (1000 * 60 * 60 * 24)
        )
      : 0

    // üî• V3: –°—Ç—Ä–∏–∫–∏ –¢–û–õ–¨–ö–û –∏–∑ –ë–î, –Ω–∏–∫–∞–∫–∏—Ö –ø–µ—Ä–µ—Å—á–µ—Ç–æ–≤
    const finalStats = {
      totalMoodEntries: moodEntries?.length || 0,
      currentStreak, // –ò–∑ –ë–î (—Å—Ç—Ä–æ–∫–∞ 156)
      longestStreak, // –ò–∑ –ë–î (—Å—Ç—Ä–æ–∫–∞ 157)
      totalElements: userStats?.total_elements || gardenElements?.length || 0,
      rareElementsFound: userStats?.rare_elements_found || rareElementsCount,
      totalDays: Math.max(
        userStats?.total_days || 0,
        daysSinceRegistration + 1
      ),
      gardensShared: userStats?.gardens_shared || 0,
      experience: userStats?.experience || 0,
      level: userStats?.level || 1,
    }

    // üîç –û–¢–õ–ê–î–ö–ê: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—Ç–∫—É–¥–∞ –±–µ—Ä—É—Ç—Å—è –¥–∞–Ω–Ω—ã–µ
    console.log('üìä Stats Sources [V3]:', {
      telegramId: user.telegram_id,
      registrationDate: registrationDate
        ? new Date(registrationDate).toISOString().split('T')[0]
        : 'unknown',
      dbStats: {
        total_days: userStats?.total_days,
        current_streak: userStats?.current_streak,
        longest_streak: userStats?.longest_streak,
        total_elements: userStats?.total_elements,
      },
      calculatedStats: {
        daysSinceRegistration,
        daysSinceRegistrationPlus1: daysSinceRegistration + 1,
        totalElements: gardenElements?.length,
        rareElements: rareElementsCount,
      },
      finalStats,
      streakSource: 'DB only (no recalculation)',
      totalDaysLogic: `Math.max(${userStats?.total_days || 0}, ${daysSinceRegistration + 1}) = ${Math.max(userStats?.total_days || 0, daysSinceRegistration + 1)}`,
    })

    return finalStats
  } catch (error) {
    console.error('Error calculating user stats:', error)
    return null
  }
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
async function checkAndUpdateAchievements(telegramId) {
  try {
    const { data, error } = await supabase.rpc(
      'check_and_unlock_achievements',
      { p_telegram_id: telegramId }
    )

    if (error) {
      console.error('Error checking achievements:', error)
      return []
    }

    return data || []
  } catch (error) {
    console.error('Achievement check failed:', error)
    return []
  }
}

/**
 * –û–±–Ω–æ–≤–ª—è–µ—Ç –æ–ø—ã—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
async function addExperience(telegramId, experiencePoints) {
  try {
    const { data, error } = await supabase.rpc('add_user_experience', {
      p_telegram_id: telegramId,
      p_experience_points: experiencePoints,
    })

    if (error) {
      console.error('Error adding experience:', error)
      return null
    }

    return data[0] || null
  } catch (error) {
    console.error('Experience update failed:', error)
    return null
  }
}

// –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º middleware –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
import { withAuth, verifyTelegramId } from './_auth.js'

/**
 * üîí –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è Supabase –∫–ª–∏–µ–Ω—Ç–∞ —Å JWT (RLS-–∑–∞—â–∏—â–µ–Ω–Ω—ã–π)
 */
async function getSupabaseClient(jwt = null) {
  if (!process.env.SUPABASE_URL) {
    throw new Error('SUPABASE_URL not configured')
  }

  // ‚úÖ –ü–†–ò–û–†–ò–¢–ï–¢: –ò—Å–ø–æ–ª—å–∑—É–µ–º JWT –¥–ª—è RLS-–∑–∞—â–∏—â–µ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
  if (jwt) {
    try {
      const { createAuthenticatedSupabaseClient } = await import('./_jwt.js')
      console.log('‚úÖ Using JWT-authenticated Supabase client (RLS enabled)')
      return await createAuthenticatedSupabaseClient(jwt)
    } catch (error) {
      console.error('‚ùå Failed to create JWT client:', error)
      // Fallback –Ω–∞ SERVICE_ROLE_KEY –Ω–∏–∂–µ
    }
  }

  // ‚ö†Ô∏è FALLBACK: SERVICE_ROLE_KEY (–º–∏–Ω—É–µ—Ç RLS, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –¥–ª—è admin –æ–ø–µ—Ä–∞—Ü–∏–π)
  if (!process.env.SUPABASE_SERVICE_ROLE_KEY) {
    throw new Error('Supabase credentials not configured')
  }

  console.warn('‚ö†Ô∏è Using SERVICE_ROLE_KEY (bypasses RLS) - migrate to JWT!')
  const { createClient } = await import('@supabase/supabase-js')
  return createClient(
    process.env.SUPABASE_URL,
    process.env.SUPABASE_SERVICE_ROLE_KEY
  )
}

/**
 * –ó–∞—â–∏—â–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ API –∑–∞–ø—Ä–æ—Å–æ–≤
 */
async function protectedHandler(req, res) {
  try {
    const { action } = req.query

    // üîë –°–ü–ï–¶–ò–ê–õ–¨–ù–´–ô –°–õ–£–ß–ê–ô: –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–ø—Ä–æ—Å—ã –æ—Ç –±–æ—Ç–∞
    const botSecret = req.headers['x-bot-secret']
    const EXPECTED_BOT_SECRET = process.env.TELEGRAM_BOT_SECRET

    if (botSecret === EXPECTED_BOT_SECRET) {
      console.log('ü§ñ Bot request detected, bypassing authentication')

      // –î–ª—è –∑–∞–ø—Ä–æ—Å–æ–≤ –æ—Ç –±–æ—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º SERVICE_ROLE_KEY –Ω–∞–ø—Ä—è–º—É—é
      const supabase = await getSupabaseClient(null) // null = –∏—Å–ø–æ–ª—å–∑—É–µ—Ç SERVICE_ROLE_KEY

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ get_profile –¥–ª—è –±–æ—Ç–∞
      if (action === 'get_profile') {
        const telegramId = req.query.telegramId || req.body.telegramId

        if (!telegramId) {
          return res.status(400).json({
            success: false,
            error: 'Missing telegramId',
          })
        }

        // –ü–æ–ª—É—á–∞–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const user = await ensureUser(parseInt(telegramId))

        // –í—ã—á–∏—Å–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        const stats = await calculateUserStats(user)

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
        const achievementUpdates = await checkAndUpdateAchievements(
          user.telegram_id
        )

        // –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const { data: userAchievements, error: achievementsError } =
          await supabase
            .from('user_achievements')
            .select(
              `
            achievement_id,
            is_unlocked,
            progress,
            unlocked_at,
            achievements!inner (
              name,
              description,
              emoji,
              category,
              rarity
            )
          `
            )
            .eq('telegram_id', user.telegram_id)

        if (achievementsError) {
          console.error('Error fetching achievements:', achievementsError)
        }

        return res.status(200).json({
          success: true,
          data: {
            user: {
              ...user,
              registration_date: user.registration_date || user.created_at,
            },
            stats,
            achievements: userAchievements || [],
            newlyUnlocked: achievementUpdates.filter(a => a.newly_unlocked),
          },
        })
      }

      // –î–ª—è –¥—Ä—É–≥–∏—Ö –¥–µ–π—Å—Ç–≤–∏–π –æ—Ç –±–æ—Ç–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫—É
      return res.status(403).json({
        success: false,
        error: 'Bot can only access get_profile action',
      })
    }

    // –î–ª—è –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ –¥–µ–π—Å—Ç–≤–∏–π –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ä–∞–±–æ—Ç–∞–µ—Ç —Å–æ —Å–≤–æ–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏
    const requestedTelegramId = req.query.telegramId || req.body.telegramId
    const authenticatedTelegramId = req.auth.telegramId

    // –ò—Å–∫–ª—é—á–µ–Ω–∏—è: get_friend_profile —Ä–∞–∑—Ä–µ—à–∞–µ—Ç –ø—Ä–æ—Å–º–æ—Ç—Ä –ø—Ä–æ—Ñ–∏–ª–µ–π –¥—Ä—É–∑–µ–π
    const allowedActionsWithDifferentId = ['get_friend_profile']

    if (
      requestedTelegramId &&
      !allowedActionsWithDifferentId.includes(action)
    ) {
      if (!verifyTelegramId(requestedTelegramId, authenticatedTelegramId)) {
        return res.status(403).json({
          success: false,
          error: 'Forbidden: You can only access your own data',
        })
      }
    }

    // üîë –ò—Å–ø–æ–ª—å–∑—É–µ–º JWT –∏–∑ req.auth –¥–ª—è RLS-–∑–∞—â–∏—â–µ–Ω–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
    const supabase = await getSupabaseClient(req.auth?.jwt)

    switch (action) {
      case 'get_profile': {
        if (req.method !== 'GET' && req.method !== 'POST') {
          return res
            .status(405)
            .json({ success: false, error: 'Method not allowed' })
        }

        let telegramId, userData

        if (req.method === 'GET') {
          telegramId = req.query.telegramId
        } else {
          // POST –º–µ—Ç–æ–¥ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–µ—Ä–µ–¥–∞—Ç—å userData –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏
          telegramId = req.body.telegramId
          userData = req.body.userData
        }

        if (!telegramId) {
          return res
            .status(400)
            .json({ success: false, error: 'Missing telegramId' })
        }

        // –ü–æ–ª—É—á–∞–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –¥–∞–Ω–Ω—ã–º–∏ Telegram
        const user = await ensureUser(parseInt(telegramId), userData)

        // –í—ã—á–∏—Å–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        const stats = await calculateUserStats(user)

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
        const achievementUpdates = await checkAndUpdateAchievements(
          user.telegram_id
        )

        // –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const { data: userAchievements, error: achievementsError } =
          await supabase
            .from('user_achievements')
            .select(
              `
            achievement_id,
            is_unlocked,
            progress,
            unlocked_at,
            achievements!inner (
              name,
              description,
              emoji,
              category,
              rarity
            )
          `
            )
            .eq('telegram_id', user.telegram_id)

        if (achievementsError) {
          console.error('Error fetching achievements:', achievementsError)
        }

        return res.status(200).json({
          success: true,
          data: {
            user: {
              ...user,
              registration_date: user.registration_date || user.created_at, // –ò—Å–ø–æ–ª—å–∑—É–µ–º created_at –∫–∞–∫ fallback
            },
            stats,
            achievements: userAchievements || [],
            newlyUnlocked: achievementUpdates.filter(a => a.newly_unlocked),
          },
        })
      }

      case 'update_privacy': {
        if (req.method !== 'POST') {
          return res
            .status(405)
            .json({ success: false, error: 'Method not allowed' })
        }

        const { telegramId, privacySettings } = req.body
        if (!telegramId || !privacySettings) {
          return res
            .status(400)
            .json({ success: false, error: 'Missing required fields' })
        }

        const user = await ensureUser(parseInt(telegramId))

        const { data, error } = await supabase
          .from('users')
          .update({ privacy_settings: privacySettings })
          .eq('telegram_id', user.telegram_id)
          .select()
          .single()

        if (error) {
          console.error('Privacy update error:', error)
          return res
            .status(500)
            .json({ success: false, error: 'Database error' })
        }

        return res.status(200).json({
          success: true,
          data: { privacy_settings: data.privacy_settings },
        })
      }

      case 'add_experience': {
        if (req.method !== 'POST') {
          return res
            .status(405)
            .json({ success: false, error: 'Method not allowed' })
        }

        const { telegramId, experiencePoints, reason } = req.body
        if (!telegramId || !experiencePoints) {
          return res
            .status(400)
            .json({ success: false, error: 'Missing required fields' })
        }

        const user = await ensureUser(parseInt(telegramId))

        // –î–æ–±–∞–≤–ª—è–µ–º –æ–ø—ã—Ç
        const experienceResult = await addExperience(
          user.telegram_id,
          experiencePoints
        )

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–æ–≤—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
        const achievementUpdates = await checkAndUpdateAchievements(
          user.telegram_id
        )

        return res.status(200).json({
          success: true,
          data: {
            experience: experienceResult.new_experience,
            level: experienceResult.new_level,
            leveledUp: experienceResult.level_up || false,
            // üÜï –ù–∞–≥—Ä–∞–¥—ã –∑–∞ level up (–≠—Ç–∞–ø 2)
            sproutReward: experienceResult.sprout_reward || 0,
            gemReward: experienceResult.gem_reward || 0,
            specialUnlock: experienceResult.special_unlock || null,
            // –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è
            newAchievements: achievementUpdates.filter(a => a.newly_unlocked),
            reason: reason || 'Unknown',
          },
        })
      }

      case 'recalculate_experience': {
        if (req.method !== 'POST') {
          return res
            .status(405)
            .json({ success: false, error: 'Method not allowed' })
        }

        const { telegramId } = req.body
        if (!telegramId) {
          return res
            .status(400)
            .json({ success: false, error: 'Missing telegramId' })
        }

        const user = await ensureUser(parseInt(telegramId))

        // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const stats = await calculateUserStats(user)
        if (!stats) {
          return res
            .status(500)
            .json({ success: false, error: 'Failed to calculate stats' })
        }

        // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–ø—ã—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        // –ü—Ä–æ—Å—Ç–∞—è —Ñ–æ—Ä–º—É–ª–∞: 10 –æ–ø—ã—Ç–∞ –∑–∞ –∑–∞–ø–∏—Å—å –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è + 15 –∑–∞ —ç–ª–µ–º–µ–Ω—Ç —Å–∞–¥–∞ + –±–æ–Ω—É—Å –∑–∞ —Å—Ç—Ä–∏–∫–∏
        const experienceFromMoods = stats.totalMoodEntries * 10
        const experienceFromElements = stats.totalElements * 15
        const experienceFromStreaks = Math.floor(stats.longestStreak / 7) * 50
        const totalCalculatedExperience =
          experienceFromMoods + experienceFromElements + experienceFromStreaks

        // –û–±–Ω–æ–≤–ª—è–µ–º –æ–ø—ã—Ç –≤ –ë–î —á–µ—Ä–µ–∑ RPC
        const { data, error } = await supabase.rpc('add_user_experience', {
          p_telegram_id: parseInt(telegramId),
          p_experience_points:
            totalCalculatedExperience - (stats.experience || 0), // –†–∞–∑–Ω–∏—Ü–∞
        })

        if (error) {
          console.error('Error recalculating experience:', error)
          return res
            .status(500)
            .json({ success: false, error: 'Failed to update experience' })
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–æ–≤—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –æ–ø—ã—Ç–∞
        const achievementUpdates = await checkAndUpdateAchievements(
          user.telegram_id
        )

        return res.status(200).json({
          success: true,
          data: {
            oldExperience: stats.experience || 0,
            newExperience: data[0]?.new_experience || totalCalculatedExperience,
            oldLevel: stats.level || 1,
            newLevel: data[0]?.new_level || 1,
            leveledUp: data[0]?.level_up || false,
            // üÜï –ù–∞–≥—Ä–∞–¥—ã –∑–∞ level up (–≠—Ç–∞–ø 2)
            sproutReward: data[0]?.sprout_reward || 0,
            gemReward: data[0]?.gem_reward || 0,
            specialUnlock: data[0]?.special_unlock || null,
            calculation: {
              fromMoods: experienceFromMoods,
              fromElements: experienceFromElements,
              fromStreaks: experienceFromStreaks,
              total: totalCalculatedExperience,
            },
            newAchievements: achievementUpdates.filter(a => a.newly_unlocked),
          },
        })
      }

      case 'get_friend_profile': {
        if (req.method !== 'GET') {
          return res
            .status(405)
            .json({ success: false, error: 'Method not allowed' })
        }

        const { telegramId, friendTelegramId } = req.query
        if (!telegramId || !friendTelegramId) {
          return res.status(400).json({
            success: false,
            error: 'Missing telegramId or friendTelegramId',
          })
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ - –¥—Ä—É–∑—å—è (–µ—Å–ª–∏ –ø—Ä–æ—Ñ–∏–ª—å –ø—Ä–∏–≤–∞—Ç–Ω—ã–π)
        const { data: friendship, error: friendshipError } = await supabase
          .from('friendships')
          .select('*')
          .or(
            `and(requester_telegram_id.eq.${telegramId},addressee_telegram_id.eq.${friendTelegramId}),and(requester_telegram_id.eq.${friendTelegramId},addressee_telegram_id.eq.${telegramId})`
          )
          .eq('status', 'accepted')
          .single()

        // –ï—Å–ª–∏ –Ω–µ –¥—Ä—É–∑—å—è, –ø—Ä–æ–≤–µ—Ä–∏–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏
        if (friendshipError || !friendship) {
          // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥—Ä—É–≥–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏
          const friend = await ensureUser(parseInt(friendTelegramId))
          const privacySettings = friend.privacy_settings || {}

          // –ï—Å–ª–∏ –ø—Ä–æ—Ñ–∏–ª—å –ø—Ä–∏–≤–∞—Ç–Ω—ã–π - —Ç—Ä–µ–±—É–µ–º –¥—Ä—É–∂–±—É
          if (!privacySettings.showProfile) {
            return res.status(403).json({
              success: false,
              error: '–ü—Ä–æ—Ñ–∏–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –∏–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤ –¥—Ä—É–∑—å—è—Ö',
            })
          }

          // –ï—Å–ª–∏ –ø—Ä–æ—Ñ–∏–ª—å –ø—É–±–ª–∏—á–Ω—ã–π - —Ä–∞–∑—Ä–µ—à–∞–µ–º –ø—Ä–æ—Å–º–æ—Ç—Ä
          console.log(
            `‚úÖ Public profile access granted for user ${friendTelegramId}`
          )
        }

        // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥—Ä—É–≥–∞
        const friend = await ensureUser(parseInt(friendTelegramId))

        // –ü–æ–ª—É—á–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏ –¥—Ä—É–≥–∞
        const privacySettings = friend.privacy_settings || {}

        // –û–±–Ω–æ–≤–ª—è–µ–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –¥—Ä—É–≥–∞ (—á—Ç–æ–±—ã –æ–Ω–∏ –±—ã–ª–∏ –∞–∫—Ç—É–∞–ª—å–Ω—ã–º–∏)
        await checkAndUpdateAchievements(friend.telegram_id)

        // –ü–æ–ª—É—á–∞–µ–º –ø—É–±–ª–∏—á–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        const stats = await calculateUserStats(friend)

        // üîç –û–¢–õ–ê–î–ö–ê: –õ–æ–≥–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥—Ä—É–≥–∞ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
        console.log('üîç Friend Profile Debug:', {
          friendTelegramId,
          friendId: friend.id,
          registrationDate: friend.registration_date,
          daysSinceReg: stats?.totalDays,
          longestStreak: stats?.longestStreak,
          totalElements: stats?.totalElements,
          privacy: privacySettings,
          fullStats: stats,
        })

        // –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è (–µ—Å–ª–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω—ã)
        let achievements = []
        if (privacySettings.shareAchievements) {
          const { data: userAchievements, error: friendAchievementsError } =
            await supabase
              .from('user_achievements')
              .select(
                `
              achievement_id,
              is_unlocked,
              unlocked_at,
              achievements!inner (
                name,
                description,
                emoji,
                category
              )
            `
              )
              .eq('telegram_id', friend.telegram_id)
              .eq('is_unlocked', true)

          if (friendAchievementsError) {
            console.error(
              'Error fetching friend achievements:',
              friendAchievementsError
            )
          }

          achievements = userAchievements || []
        }

        return res.status(200).json({
          success: true,
          data: {
            user: {
              id: friend.id,
              telegram_id: friend.telegram_id,
              first_name: friend.first_name,
              last_name: friend.last_name,
              username: friend.username,
              photo_url: friend.photo_url,
              level: friend.level,
              registration_date: friend.registration_date || friend.created_at,
            },
            stats: privacySettings.shareGarden ? stats : null,
            achievements: privacySettings.shareAchievements ? achievements : [],
            privacy: {
              showProfile: privacySettings.showProfile,
              shareGarden: privacySettings.shareGarden,
              shareAchievements: privacySettings.shareAchievements,
            },
          },
        })
      }

      case 'update_user_stats': {
        if (req.method !== 'POST') {
          return res
            .status(405)
            .json({ success: false, error: 'Method not allowed' })
        }

        const { telegramId } = req.body
        if (!telegramId) {
          return res
            .status(400)
            .json({ success: false, error: 'Missing telegramId' })
        }

        try {
          // –í—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –ø–µ—Ä–µ—Å—á–µ—Ç–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –≤ –ë–î
          const { data, error } = await supabase.rpc('update_user_stats', {
            target_telegram_id: parseInt(telegramId),
          })

          if (error) {
            console.error('Error updating user stats:', error)
            return res.status(500).json({
              success: false,
              error: 'Failed to update user stats',
              details: error.message,
            })
          }

          return res.status(200).json({
            success: true,
            data: {
              message: 'User stats updated successfully',
              stats: data,
            },
          })
        } catch (err) {
          console.error('Stats update error:', err)
          return res.status(500).json({
            success: false,
            error: 'Failed to update user stats',
            details: err.message,
          })
        }
      }

      case 'update_all_user_stats': {
        if (req.method !== 'POST') {
          return res
            .status(405)
            .json({ success: false, error: 'Method not allowed' })
        }

        try {
          // –í—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –º–∞—Å—Å–æ–≤–æ–≥–æ –ø–µ—Ä–µ—Å—á–µ—Ç–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
          const { data, error } = await supabase.rpc('update_all_user_stats')

          if (error) {
            console.error('Error updating all user stats:', error)
            return res.status(500).json({
              success: false,
              error: 'Failed to update all user stats',
              details: error.message,
            })
          }

          return res.status(200).json({
            success: true,
            data: {
              message: 'All user stats updated successfully',
              results: data,
            },
          })
        } catch (err) {
          console.error('Bulk stats update error:', err)
          return res.status(500).json({
            success: false,
            error: 'Failed to update all user stats',
            details: err.message,
          })
        }
      }

      case 'update_notifications': {
        if (req.method !== 'POST') {
          return res
            .status(405)
            .json({ success: false, error: 'Method not allowed' })
        }

        const { telegramId, notificationSettings } = req.body

        if (!telegramId || !notificationSettings) {
          return res.status(400).json({
            success: false,
            error:
              'Missing required parameters: telegramId, notificationSettings',
          })
        }

        try {
          console.log(
            `üîî Updating notification settings for user ${telegramId}:`,
            notificationSettings
          )

          // üîë –ò—Å–ø–æ–ª—å–∑—É–µ–º JWT –∏–∑ req.auth –¥–ª—è RLS-–∑–∞—â–∏—â–µ–Ω–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
          const supabase = await getSupabaseClient(req.auth?.jwt)

          const { data, error } = await supabase
            .from('users')
            .update({
              notification_settings: notificationSettings,
              updated_at: new Date().toISOString(),
            })
            .eq('telegram_id', telegramId)
            .select()

          if (error) {
            console.error('Failed to update notification settings:', error)
            return res.status(500).json({
              success: false,
              error: 'Failed to update notification settings',
            })
          }

          console.log(`‚úÖ Notification settings updated for user ${telegramId}`)

          return res.status(200).json({
            success: true,
            data: {
              notificationSettings,
              message: 'Notification settings updated successfully',
            },
          })
        } catch (error) {
          console.error('Update notifications error:', error)
          return res.status(500).json({
            success: false,
            error: 'Internal server error',
          })
        }
      }

      // ‚ö†Ô∏è –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ - —Ç—Ä–µ–±—É–µ—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–π –∑–∞—â–∏—Ç—ã
      case 'update_all_user_stats': {
        if (req.method !== 'POST') {
          return res
            .status(405)
            .json({ success: false, error: 'Method not allowed' })
        }

        // üîê –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ - –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –∫–ª—é—á –∏–ª–∏ IP
        const adminKey = req.headers['x-admin-key']
        const EXPECTED_ADMIN_KEY = process.env.ADMIN_API_KEY

        if (!EXPECTED_ADMIN_KEY || adminKey !== EXPECTED_ADMIN_KEY) {
          console.warn('‚ö†Ô∏è Unauthorized attempt to call administrative API')
          return res.status(403).json({
            success: false,
            error:
              'Forbidden: Administrative action requires special authorization',
          })
        }

        try {
          // –í—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –º–∞—Å—Å–æ–≤–æ–≥–æ –ø–µ—Ä–µ—Å—á–µ—Ç–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
          const { data, error } = await supabase.rpc('update_all_user_stats')

          if (error) {
            console.error('Error updating all user stats:', error)
            return res.status(500).json({
              success: false,
              error: 'Failed to update all user stats',
              details: error.message,
            })
          }

          return res.status(200).json({
            success: true,
            data: {
              message: 'All user stats updated successfully',
              results: data,
            },
          })
        } catch (err) {
          console.error('Bulk stats update error:', err)
          return res.status(500).json({
            success: false,
            error: 'Failed to update all user stats',
            details: err.message,
          })
        }
      }

      default:
        return res.status(400).json({ success: false, error: 'Invalid action' })
    }
  } catch (error) {
    console.error('Profile API Error:', error)
    console.error('Stack trace:', error.stack)
    return res.status(500).json({
      success: false,
      error: 'Internal server error',
      details:
        process.env.NODE_ENV === 'development' ? error.message : undefined,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
    })
  }
}

// –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∑–∞—â–∏—â–µ–Ω–Ω—ã–π handler
export default withAuth(protectedHandler)
